########################################################################################################################
# Summary:             BLEN substitutions file to generate PVs for CPSW registers
# Author:              C. Ford <caf@slac.stanford.edu>
# Date:                19-mar-2017 
# YAML config version: AmcCarrierBlen_00000016
########################################################################################################################

########################################################################################################################
# Macros:
#   P,R: The PV name as $(P):$(R)
#   DESC, PINI, SCAN, NELM, etc.: The same fields on the records
#   PORT: The asyn port name. It must match the port name given when calling "YCPSWASYNConfig" on st.cmd
#   PARAM: The asyn paramter name. It must be defined in the dictionary file and assigned to a register
#   AMC: The AMC hardware slot (0 or 1)
########################################################################################################################

#======================================
# Registers with ScalVal_RO interfaces
#======================================
# Single register
file "RegisterIn.template" { pattern
{ P,          R,              DESC,                           PINI,   SCAN,       PORT, EGU,  PARAM         }
{ $(P), RATE,           "Trigger rate over 1 sec",      "YES",  "1 second", $(PORT),   "Hz", AMC$(AMC):SENS0:RATE          }
{ $(P), AmcClkFreq,     "AMC Clock frequency",          "YES",  "1 second", $(PORT),   "Hz", AMC$(AMC):AmcClkFreq    }
{ $(P), MuxTrigCnt,     "Valid DAQ triggers",           "YES",  "1 second", $(PORT),   "",   AMC$(AMC):MuxTrigCnt    }
{ $(P), MuxFrzStat,     "Freeze buf status",            "YES",  "1 second", $(PORT),   "",   AMC$(AMC):MuxFrzStat    }
{ $(P), MuxCascStat,    "Cascade trigger status",       "YES",  "1 second", $(PORT),   "",   AMC$(AMC):MuxCascStat   }
{ $(P), MuxTrigHwArm,   "HW trigger armed status",      "YES",  "1 second", $(PORT),   "",   AMC$(AMC):MuxTrigHwArm  }
{ $(P), MuxTrigHwStat,  "HW trigger status",            "YES",  "1 second", $(PORT),   "",   AMC$(AMC):MuxTrigHwStat }
{ $(P), MuxTrigStat,    "Combined trigger status",      "YES",  "1 second", $(PORT),   "",   AMC$(AMC):MuxTrigStat   }
{ $(P), MuxTrigSwStat,  "SW trigger status",            "YES",  "1 second", $(PORT),   "",   AMC$(AMC):MuxTrigSwStat }
{ $(P), WEBBurstSz,     "Burst size",                   "YES",  "1 second", $(PORT),   "",   AMC$(AMC):WEBBurstSz    }
{ $(P), DSPVers,        "System generator core vers",   "YES",  "1 second", $(PORT),   "",   AMC$(AMC):DSPVers       }
}

# Array of register
file "RegisterArrayIn.template" { pattern
{ P,          R,             DESC,                          NELM,   PINI,   SCAN,       PORT,  PARAM       }
{ $(P), AdcData,       "ADC Data[3:0]",               4,     "YES",   "1 second", $(PORT),    AMC$(AMC):AdcData     }
{ $(P), MuxInDatVal,   "Incoming data valid",         4,     "YES",   "1 second", $(PORT),    AMC$(AMC):MuxInDatVal }
{ $(P), MuxStrmEna,    "Output stream enabled",       4,     "YES",   "1 second", $(PORT),    AMC$(AMC):MuxStrmEna  }
{ $(P), MuxStrmErr,    "Error during last acq",       4,     "YES",   "1 second", $(PORT),    AMC$(AMC):MuxStrmErr  }
{ $(P), MuxStrmOflw,   "Raw diag stream ctrl oflw",   4,     "YES",   "1 second", $(PORT),    AMC$(AMC):MuxStrmOflw }
{ $(P), MuxStrmPs,     "Raw diag stream ctrl pause",  4,     "YES",   "1 second", $(PORT),    AMC$(AMC):MuxStrmPs   }
{ $(P), MuxStrmRdy,    "Raw diag stream ctrl ready",  4,     "YES",   "1 second", $(PORT),    AMC$(AMC):MuxStrmRdy  }
{ $(P), MuxFrameCnt,    "4096 byte frames sent",      4,     "YES",   "1 second", $(PORT),    AMC$(AMC):MuxFrameCnt }
{ $(P), MuxTmstmp,     "Timestamp 63:0",              2,     "YES",   "1 second", $(PORT),    AMC$(AMC):MuxTmstmp   }
{ $(P), WEBDone        "",                            4,     "YES",   "1 second", $(PORT),    AMC$(AMC):WEBDone     }
{ $(P), WEBEmpty       "",                            4,     "YES",   "1 second", $(PORT),    AMC$(AMC):WEBEmpty    }
{ $(P), WEBError       "",                            4,     "YES",   "1 second", $(PORT),    AMC$(AMC):WEBError    }
{ $(P), WEBFSTrig      "Frames since trigger",        4,     "YES",   "1 second", $(PORT),    AMC$(AMC):WEBFSTrig   }
{ $(P), WEBFull        "",                            4,     "YES",   "1 second", $(PORT),    AMC$(AMC):WEBFull     }
{ $(P), WEBTrigAddr    "",                            4,     "YES",   "1 second", $(PORT),    AMC$(AMC):WEBTrigAddr }
{ $(P), WEBTrigd       "Triggered",                   4,     "YES",   "1 second", $(PORT),    AMC$(AMC):WEBTrigd    }
{ $(P), WEBWrAddr      "",                            4,     "YES",   "1 second", $(PORT),    AMC$(AMC):WEBWrAddr   }
}

# Array of 8-bit register as a string
file "RegisterArrayChar.template" { pattern
{ P,        R,              DESC,                           NELM,   PINI,   SCAN,       PORT,  PARAM       }
}

# ENUM register
file "RegisterEnumBIn.template" { pattern
{ P,        R,              DESC,                    PINI,   ZNAM,       ONAM,       SCAN,      PORT, PARAM     }
}

#======================================
# Register with ScalVal interfaces
#======================================

file "RegisterOut.template" { pattern
{ P,        R,              DESC,                                       PINI,   SCAN,       PORT,  PARAM       }
{ $(P), ModeS0,             "BLEN mode, sensor 0"               "NO",   "Passive",  $(PORT),    AMC$(AMC):SENS0:Mode }
{ $(P), ModeS1,             "BLEN mode, sensor 1"               "NO",   "Passive",  $(PORT),    AMC$(AMC):SENS1:Mode }
{ $(P), NumSamp0S0,         "Number of samples 0, sensor 0"     "NO",   "Passive",  $(PORT),    AMC$(AMC):SENS0:NumSamp0 }
{ $(P), NumSamp0S1,         "Number of samples 0, sensor 1"     "NO",   "Passive",  $(PORT),    AMC$(AMC):SENS1:NumSamp0 }
{ $(P), NumSamp1S0,         "Number of samples 1, sensor 0"     "NO",   "Passive",  $(PORT),    AMC$(AMC):SENS0:NumSamp1 }
{ $(P), NumSamp1S1,         "Number of samples 1, sensor 1"     "NO",   "Passive",  $(PORT),    AMC$(AMC):SENS1:NumSamp1 }
{ $(P), TrigDelay1S0,       ""                                  "NO",   "Passive",  $(PORT),    AMC$(AMC):SENS0:TrigDelay1 }
{ $(P), TrigDelay1S1,       ""                                  "NO",   "Passive",  $(PORT),    AMC$(AMC):SENS1:TrigDelay1 }
{ $(P), TrigDelay2S0,       ""                                  "NO",   "Passive",  $(PORT),    AMC$(AMC):SENS0:TrigDelay2 }
{ $(P), TrigDelay2S1,       ""                                  "NO",   "Passive",  $(PORT),    AMC$(AMC):SENS1:TrigDelay2 }
# Trigger to Waveforms (TLR4)
{ $(P), SelFld4,    "fields to use for trig msg comparison",  "NO",   "Passive",  $(PORT),    AMC$(AMC):TLR4:SelFld }
{ $(P), SelSrc4,    "soft-b0, tmg-b01, trig0-b10, trig1-b11", "NO",   "Passive",  $(PORT),    AMC$(AMC):TLR4:SelSrc }
{ $(P), SftTrig4,   "used field to only mask bit of interest","NO",   "Passive",  $(PORT),    AMC$(AMC):TLR4:SftTrig }
{ $(P), BeamRq4,    "used field to only mask bit of interest","NO",   "Passive",  $(PORT),    AMC$(AMC):TLR4:BeamRq }
{ $(P), FxRate4,    "used field to only mask bit of interest","NO",   "Passive",  $(PORT),    AMC$(AMC):TLR4:FxRate }
{ $(P), OutPol4,    "trigger invert: normal b0, inverted b1", "NO",   "Passive",  $(PORT),    AMC$(AMC):TLR4:OutPol }
{ $(P), TrigDly4,   "trigger delay in clock cycles",          "NO",   "Passive",  $(PORT),    AMC$(AMC):TLR4:TrigDly }
{ $(P), TrigStr4,   "trigger stretch in clock cycles",        "NO",   "Passive",  $(PORT),    AMC$(AMC):TLR4:TrigStr }
# Trigger to Calculations (TLR6)
{ $(P), SelFld6,    "fields to use for trig msg comparison",  "NO",   "Passive",  $(PORT),    AMC$(AMC):TLR6:SelFld }
{ $(P), SelSrc6,    "soft-b0, tmg-b01, trig0-b10, trig1-b11", "NO",   "Passive",  $(PORT),    AMC$(AMC):TLR6:SelSrc }
{ $(P), SftTrig6,   "used field to only mask bit of interest","NO",   "Passive",  $(PORT),    AMC$(AMC):TLR6:SftTrig }
{ $(P), BeamRq6,    "used field to only mask bit of interest","NO",   "Passive",  $(PORT),    AMC$(AMC):TLR6:BeamRq }
{ $(P), FxRate6,    "used field to only mask bit of interest","NO",   "Passive",  $(PORT),    AMC$(AMC):TLR6:FxRate }
{ $(P), OutPol6,    "trigger invert: normal b0, inverted b1", "NO",   "Passive",  $(PORT),    AMC$(AMC):TLR6:OutPol }
{ $(P), TrigDly6,   "trigger delay in clock cycles",          "NO",   "Passive",  $(PORT),    AMC$(AMC):TLR6:TrigDly }
{ $(P), TrigStr6,   "trigger stretch in clock cycles",        "NO",   "Passive",  $(PORT),    AMC$(AMC):TLR6:TrigStr }
}

file "RegisterOutRBV.template" { pattern
{ P,    R,                   DESC,                               PINI,   SCAN,        PORT,       PARAM       }
{ $(P), ModeS0RBV,           "BLEN mode, sensor 0"               "YES",  "1 second",  $(PORT),    AMC$(AMC):SENS0:Mode }
{ $(P), ModeS1RBV,           "BLEN mode, sensor 1"               "YES",  "1 second",  $(PORT),    AMC$(AMC):SENS1:Mode }
{ $(P), NumSamp0S0RBV,       "Number of samples 0, sensor 0"     "YES",  "1 second",  $(PORT),    AMC$(AMC):SENS0:NumSamp0 }
{ $(P), NumSamp0S1RBV,       "Number of samples 0, sensor 1"     "YES",  "1 second",  $(PORT),    AMC$(AMC):SENS1:NumSamp0 }
{ $(P), NumSamp1S0RBV,       "Number of samples 1, sensor 0"     "YES",  "1 second",  $(PORT),    AMC$(AMC):SENS0:NumSamp1 }
{ $(P), NumSamp1S1RBV,       "Number of samples 1, sensor 1"     "YES",  "1 second",  $(PORT),    AMC$(AMC):SENS1:NumSamp1 }
{ $(P), TrigDelay1S0RBV,     ""                                  "YES",  "1 second",  $(PORT),    AMC$(AMC):SENS0:TrigDelay1 }
{ $(P), TrigDelay1S1RBV,     ""                                  "YES",  "1 second",  $(PORT),    AMC$(AMC):SENS1:TrigDelay1 }
{ $(P), TrigDelay2S0RBV,     ""                                  "YES",  "1 second",  $(PORT),    AMC$(AMC):SENS0:TrigDelay2 }
{ $(P), TrigDelay2S1RBV,     ""                                  "YES",  "1 second",  $(PORT),    AMC$(AMC):SENS1:TrigDelay2 }
# Trigger to Waveforms (TLR4)
{ $(P), SelFld4RBV,    "fields to use for trig msg comparison",  "YES",  "1 second",  $(PORT),    AMC$(AMC):TLR4:SelFld }
{ $(P), SelSrc4RBV,    "soft-b0, tmg-b01, trig0-b10, trig1-b11", "YES",  "1 second",  $(PORT),    AMC$(AMC):TLR4:SelSrc }
{ $(P), SftTrig4RBV,   "used field to only mask bit of interest","YES",  "1 second",  $(PORT),    AMC$(AMC):TLR4:SftTrig }
{ $(P), BeamRq4RBV,    "used field to only mask bit of interest","YES",  "1 second",  $(PORT),    AMC$(AMC):TLR4:BeamRq }
{ $(P), FxRate4RBV,    "used field to only mask bit of interest","YES",  "1 second",  $(PORT),    AMC$(AMC):TLR4:FxRate }
{ $(P), OutPol4RBV,    "trigger invert: normal b0, inverted b1", "YES",  "1 second",  $(PORT),    AMC$(AMC):TLR4:OutPol }
{ $(P), TrigDly4RBV,   "trigger delay in clock cycles",          "YES",  "1 second",  $(PORT),    AMC$(AMC):TLR4:TrigDly }
{ $(P), TrigStr4RBV,   "trigger stretch in clock cycles",        "YES",  "1 second",  $(PORT),    AMC$(AMC):TLR4:TrigStr }
# Trigger to Calculations (TLR6)
{ $(P), SelFld6RBV,    "fields to use for trig msg comparison",  "YES",  "1 second",  $(PORT),    AMC$(AMC):TLR6:SelFld }
{ $(P), SelSrc6RBV,    "soft-b0, tmg-b01, trig0-b10, trig1-b11", "YES",  "1 second",  $(PORT),    AMC$(AMC):TLR6:SelSrc }
{ $(P), SftTrig6RBV,   "used field to only mask bit of interest","YES",  "1 second",  $(PORT),    AMC$(AMC):TLR6:SftTrig }
{ $(P), BeamRq6RBV,    "used field to only mask bit of interest","YES",  "1 second",  $(PORT),    AMC$(AMC):TLR6:BeamRq }
{ $(P), FxRate6RBV,    "used field to only mask bit of interest","YES",  "1 second",  $(PORT),    AMC$(AMC):TLR6:FxRate }
{ $(P), OutPol6RBV,    "trigger invert: normal b0, inverted b1", "YES",  "1 second",  $(PORT),    AMC$(AMC):TLR6:OutPol }
{ $(P), TrigDly6RBV,   "trigger delay in clock cycles",          "YES",  "1 second",  $(PORT),    AMC$(AMC):TLR6:TrigDly }
{ $(P), TrigStr6RBV,   "trigger stretch in clock cycles",        "YES",  "1 second",  $(PORT),    AMC$(AMC):TLR6:TrigStr }
}

# ENUM register
file "RegisterEnumBOut.template" { pattern
{ P,        R,              DESC,        PINI   ZNAM,        ONAM,     SCAN,       PORT, PARAM     }
{ $(P), AutoRearm,   "Auto rearm", "NO",  "Disabled", "Enabled", "Passive",  $(PORT),   AMC$(AMC):AutoRearm }
}

file "RegisterEnumBOutRBV.template" { pattern
{ P,        R,              DESC,         PINI    ZNAM,        ONAM,     SCAN,        PORT, PARAM     }
{ $(P), AutoRearmRBV, "Auto rearm", "YES",  "Disabled", "Enabled", ".5 second",  $(PORT),   AMC$(AMC):AutoRearm }
}

#======================================
# Register with DoubleVal_RO interfaces
#======================================

file "RegisterDoubleIn.template" { pattern
{ P,        R,                DESC,                     PINI,   SCAN,         PORT,       EGU,        PARAM                     }
{ $(P),     AddSums0,         "",                       "YES",  ".5 second",  $(PORT),    "",         AMC$(AMC):AddSums0        }
{ $(P),     SUM,              "",                       "YES",  ".5 second",  $(PORT),    "",         AMC$(AMC):SUM             }
{ $(P),     AddSums2,         "",                       "YES",  ".5 second",  $(PORT),    "",         AMC$(AMC):AddSums2        }
{ $(P),     AddSums3,         "",                       "YES",  ".5 second",  $(PORT),    "",         AMC$(AMC):AddSums3        }
{ $(P),     AddSums4,         "",                       "YES",  ".5 second",  $(PORT),    "",         AMC$(AMC):AddSums4        }
{ $(P),     AddSums5,         "",                       "YES",  ".5 second",  $(PORT),    "",         AMC$(AMC):AddSums5        }
{ $(P),     AddSums0Gap,      "",                       "YES",  ".5 second",  $(PORT),    "",         AMC$(AMC):AddSums0Gap     }
{ $(P),     AddSums1Gap,      "",                       "YES",  ".5 second",  $(PORT),    "",         AMC$(AMC):AddSums1Gap     }
{ $(P),     AddSums2Sensors,  "",                       "YES",  ".5 second",  $(PORT),    "",         AMC$(AMC):AddSums2Sensors }
{ $(P),     TMIT,             "Transmitted intensity",  "YES",  ".5 second",  $(PORT),    "pC",       AMC$(AMC):TMIT            }
{ $(P),     IMAX,             "",                       "YES",  ".5 second",  $(PORT),    "A",        AMC$(AMC):IMAX            }
}

#======================================
# Register with DoubleVal interfaces
#======================================

file "RegisterDoubleOut.template" { pattern
{ P,              R,            DESC,                         PINI,  SCAN,        PORT,   EGU,    PARAM   }
{ $(P),     CoefA0,       "Coef A0 for 1st group",      "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefA0 }
{ $(P),     CoefA1,       "Coef A1 for 2nd group",      "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefA1 }
{ $(P),     CoefA2,       "Coef A2 for 3rd group",      "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefA2 }
{ $(P),     CoefA3,       "Coef A3",                    "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefA3 }
{ $(P),     CoefA4,       "Coef A4",                    "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefA4 }
{ $(P),     CoefA5,       "Coef A5",                    "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefA5 }
{ $(P),     CoefB,        "Coef B",                     "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefB  }
{ $(P),     CoefC,        "Coef C",                     "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefC  }
{ $(P),     CoefD,        "Coef D",                     "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefD  }
{ $(P),     CoefE,        "Coef E",                     "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefE  }
{ $(P),     CoefF,        "Coef F",                     "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefF  }
{ $(P),     CoefG,        "Coef G",                     "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefG  }
{ $(P),     CoefH,        "Coef H",                     "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefH  }
{ $(P),     CoefI,        "Coef I",                     "NO",  "Passive",   $(PORT),     "",     AMC$(AMC):CoefI  }
}

file "RegisterDoubleOutRBV.template" { pattern
{ P,              R,            DESC,                         PINI,   SCAN,       PORT,   EGU,    PARAM   }
{ $(P),     CoefA0RBV,    "Coef A0 for 1st group",      "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefA0 }
{ $(P),     CoefA1RBV,    "Coef A1 for 2nd group",      "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefA1 }
{ $(P),     CoefA2RBV,    "Coef A2 for 3rd group",      "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefA2 }
{ $(P),     CoefA3RBV,    "Coef A3",                    "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefA3 }
{ $(P),     CoefA4RBV,    "Coef A4",                    "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefA4 }
{ $(P),     CoefA5RBV,    "Coef A5",                    "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefA5 }
{ $(P),     CoefBRBV,     "Coef B",                     "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefB  }
{ $(P),     CoefCRBV,     "Coef C",                     "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefC  }
{ $(P),     CoefDRBV,     "Coef D",                     "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefD  }
{ $(P),     CoefERBV,     "Coef E",                     "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefE  }
{ $(P),     CoefFRBV,     "Coef F",                     "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefF  }
{ $(P),     CoefGRBV,     "Coef G",                     "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefG  }
{ $(P),     CoefHRBV,     "Coef H",                     "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefH  }
{ $(P),     CoefIRBV,     "Coef I",                     "YES", "1 second",  $(PORT),     "",     AMC$(AMC):CoefI  }
}

#======================================
# Register with Command interfaces
#======================================
file "RegisterCommand.template" { pattern
{ P,            R,            DESC,                            PINI,   SCAN,       PORT,   PARAM   }
{ $(P),   WEBInit,      "Waveform engine buf init",      "NO",  "Passive",   $(PORT),     AMC$(AMC):WEBInit }
{ $(P),   InitAmcCard,  "Init JESD modules",             "NO",  "Passive",   $(PORT),     AMC$(AMC):InitAmcCard }
}


#======================================
# Register with Stream interfaces
#======================================

file "RegisterStream.template" {pattern
{ P,      R,      DESC,                                   NELM,    PINI,   PORT,     PARAM       }
{ $(P),   RWF,    "Raw waveform (32-bit)",                1000,    "NO",   $(PORT),  AMC$(AMC):Stream0  }
{ $(P),   IWF,    "Integration window waveform (32-bit)", 1000,    "NO",   $(PORT),  AMC$(AMC):Stream3  }
}

# For Stream interfaces, an additional parameter is automatically created
# and the name is generated adding ":16" to the original parameter name
# This gives access to the same stream data, but as 16-bit words which
# is the case for ADC samples for example. Note that the NELM is 2x

file "RegisterStream16.template" {pattern
{ P,      R,      DESC,                                   NELM,    PINI,   PORT,     PARAM       }
{ $(P),   RWFS,   "Raw waveform (16-bit)",                2000,    "NO",   $(PORT),  AMC$(AMC):Stream0:16  }
{ $(P),   IWFS,   "Integration window waveform (16-bit)", 2000,    "NO",   $(PORT),  AMC$(AMC):Stream3:16  }
}
